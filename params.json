{"name":"Ioguide","tagline":"Io Language Guide","body":"# Io Programming Guide\r\n\r\n## Introduction\r\n\r\n###  Overview\r\n\r\nIo is a dynamic prototype-based programming language. The ideas in Io are mostly inspired by *Smalltalk* (all values are objects), *Self* (prototype-based), *NewtonScript* (differential inheritance), *Act1* (actors and futures for concurrency), *Lisp* (code is a runtime inspectable / modifiable tree) and *Lua* (small, embeddable).\r\n\r\n###  Perspective\r\n\r\nThe focus of programming language research for the last thirty years has been to combine the expressive power of high level languages like *Smalltalk* and the performance of low level language like *C* with little attention paid to advancing expressive power itself. The result has been a series of languages which are neither as fast as *C* or as expressive as *Smalltalk*.\r\n\r\nIo's purpose is to refocus attention on expressiveness by exploring higher level dynamic programming features with greater levels of runtime flexibility and simplified programming syntax and semantics.\r\n\r\nIn Io, all values are ***objects*** (of which, anything can change at runtime, including slots, methods and inheritance), all code is made up of ***expressions*** (which are runtime inspectable and modifiable) and all expressions are made up of dynamic ***message*** sends (including assignment and control structures).\r\n\r\nExecution contexts themselves are objects and activatable objects such as methods/blocks and functions are unified into blocks with assignable scope. *Concurrency* is made more easily manageable through *actors* and implemented using coroutines for scalability.\r\n\r\n###  Goals\r\n\r\nTo be a language that is:\r\n\r\n#### simple\r\n\r\n- conceptually simple and consistent\r\n- easily embedded and extended\r\n\r\n#### powerful\r\n\r\n- highly dynamic and introspective\r\n- highly concurrent (via coroutines and async i/o)\r\n\r\n#### practical\r\n\r\n- fast enough\r\n- multi-platform\r\n- unrestrictive B<BSD/MIT> license\r\n- comprehensive standard packages in distro\r\n\r\n#### Downloading\r\n\r\nIo distributions are available at:\r\n\r\n    http://iolanguage.com\r\n\r\n###  Installing\r\n\r\nFirst compile the Io vm:\r\n\r\n    make vm\r\n    sudo make install\r\n\r\n#### Installing Addon Dependencies\r\n\r\nSome of Io's addons require libraries that may not be installed on your system already. To install these automatically, type either:\r\n\r\n    su -c \"sudo make aptget\"\r\n\r\nor:\r\n\r\n    su -c \"make emerge\"\r\n\r\nor:\r\n\r\n    sudo make port\r\n\r\nDepending on which package installer you use. (port is for OSX)\r\n\r\n#### Compiling Addons\r\n\r\nTo build, from the top folder, run:\r\n\r\n    make\r\n\r\nBinaries will be placed in the _build/binaries subfolder. To install:\r\n\r\n    sudo make install\r\n\r\nor, if you'd like the install to simply link to your development folder:\r\n\r\n    sudo make linkInstall\r\n\r\nand to run all unit tests:\r\n\r\n    make test\r\n\r\nDon't worry if some of the *addons* won't build unless it's a particular addon that you need. *Addons* are just optional libraries.\r\n\r\n#### Notes\r\n\r\nTo make a particular *addon*, you can do:\r\n\r\n    make AddonName\r\n\r\nAfter doing a pull from the source control repo, be sure to do:\r\n\r\n    make clean; make\r\n\r\nTo test just the vm:\r\n\r\n    make testvm\r\n\r\nAnd to update the reference documentation (found in docs/IoReference.html) from the source code:\r\n\r\n    make doc\r\n\r\n###  Binaries\r\n\r\nIo builds two executables and places them in the binaries folder. They are:\r\n\r\n    io_static\r\n    io\r\n\r\nThe io_static executable contains the *vm* with a minimal set of primitives all statically linked into the executable. The io executable contains just enough to load the iovm dynamically linked library and is able to dynamically load io addons when they are referenced.\r\n\r\n###  Running Scripts\r\n\r\nAn example of running a script:\r\n\r\n    io samples/misc/HelloWorld.io\r\n\r\nThere is no main() function or object that gets executed first in Io. Scripts are executed when compiled.\r\n\r\n#### Interactive Mode\r\n\r\nRunning:\r\n\r\n    ./_build/binaries/io\r\n\r\nOr, if Io is installed, running:\r\n\r\n    io\r\n\r\nwill open the Io interpreter prompt.\r\n\r\nYou can evaluate code by entering it directly. Example:\r\n\r\n    Io> \"Hello world!\" println\r\n    ==> Hello world!\r\n\r\nExpressions are evaluated in the context of the *Lobby*:\r\n\r\n    Io> print\r\n    [printout of lobby contents]\r\n\r\nIf you have a F<.iorc> file in your home folder, it will be evaled before the interactive prompt starts.\r\n\r\n#### Inspecting objects\r\n\r\nYou can get a list of the *slots* of an *object* like this:\r\n\r\n    Io> someObject slotNames\r\n\r\nTo show them in sorted order:\r\n\r\n    Io> someObject slotNames sort\r\n\r\nFor a nicely formatted description of an object, the **slotSummary** method is handy:\r\n\r\n    Io> slotSummary\r\n    ==>  Object_0x20c4e0:\r\n    Lobby            = Object_0x20c4e0\r\n    Protos           = Object_0x20bff0\r\n    exit             = method(...)\r\n    forward          = method(...)\r\n\r\nExploring further:\r\n\r\n    Io> Protos\r\n    ==>  Object_0x20bff0:\r\n    Addons           = Object_0x20c6f0\r\n    Core             = Object_0x20c4b0\r\n    \r\n    Io> Protos Addons\r\n    ==>  Object_0x20c6f0:\r\n    ReadLine         = Object_0x366a10\r\n\r\nOnly *ReadLine* is seen in the Addons since no other Addons have been loaded yet.\r\n\r\nInspecting a method will print a decompiled version of it:\r\n\r\n    Io> Lobby getSlot(\"forward\")\r\n    ==> # io/Z_Importer.io:65\r\n    method(\r\n    Importer import(call)\r\n    )\r\n\r\n#### **doFile** and **doString**\r\n\r\nA script can be run from the interactive mode using the **doFile** method:\r\n\r\n    doFile(\"scriptName.io\")\r\n\r\nThe evaluation context of **doFile** is the receiver, which in this case would be the *lobby*. To evaluate the script in the context of some other object, simply send the **doFile** message to it:\r\n\r\n    someObject doFile(\"scriptName.io\")\r\n\r\nThe **doString** method can be used to evaluate a string:\r\n\r\n    Io> doString(\"1+1\")\r\n    ==> 2\r\n\r\nAnd to evaluate a string in the context of a particular object:\r\n\r\n    someObject doString(\"1 + 1\")\r\n\r\n#### Command Line Arguments\r\n\r\nExample of printing out command line arguments:\r\n\r\n    System args foreach(k, v, write(\"'\", v, \"'\\n\"))\r\n\r\n#### launchPath\r\n\r\nThe System B<\"launchPath\"> slot is set to the location of the initial source file that is executed; when the interactive prompt is started (without specifying a source file to execute), the launchPath is the current working directory:\r\n\r\n    System launchPath\r\n\r\n## Syntax\r\n\r\n###  Expressions\r\n\r\nIo has no keywords or statements. Everything is an expression composed entirely of messages, each of which is a runtime accessible object. The informal BNF description:\r\n\r\n    exp        ::= { message | terminator }\r\n    message    ::= symbol [arguments]\r\n    arguments  ::= \"(\" [exp [ { \",\" exp } ]] \")\"\r\n    symbol     ::= identifier | number | string\r\n    terminator ::= \"\\n\" | \";\"\r\n\r\nFor performance reasons, String and Number literal messages have their results cached in their message objects.\r\n\r\n###  Messages\r\n\r\nMessage arguments are passed as expressions and evaluated by the receiver. Selective evaluation of arguments can be used to implement control flow. Examples:\r\n\r\n    for(i, 1, 10, i println)\r\n    a := if(b == 0, c + 1, d)\r\n\r\nIn the above code, B<\"for\"> and B<\"if\"> are just normal messages, not special forms or keywords.\r\n\r\nLikewise, dynamic evaluation can be used with enumeration without the need to wrap the expression in a block. Examples:\r\n\r\n    people select(person, person age < 30)\r\n    names := people map(person, person name)\r\n\r\nMethods like map and select will typically apply the expression directly to the values if only the expression is provided:\r\n\r\n    people select(age < 30)\r\n    names := people map(name)\r\n\r\nThere is also some syntax sugar for operators (including assignment), which are handled by an Io macro executed on the expression after it is compiled into a message tree. Some sample source code:\r\n\r\n    Account         := Object clone\r\n    Account balance := 0\r\n    Account deposit := method(amount,\r\n    balance          = balance + amount\r\n    )\r\n    \r\n    account := Account clone\r\n    account deposit(10.00)\r\n    account balance println\r\n\r\nLike Self[2], Io's syntax does not distinguish between accessing a slot containing a method from one containing a variable.\r\n\r\n###  Operators\r\n\r\nAn operator is just a message whose name contains no alphanumeric characters (other than \"B<;>\", \"*_*\", 'B<\">') or is one of the following words: **or**, **and**, **return**. Example:\r\n\r\n    1 + 2\r\n\r\nThis just gets compiled into the normal message:\r\n\r\n    1 +(2)\r\n\r\nWhich is the form you can use if you need to do grouping:\r\n\r\n    1 +(2 * 4)\r\n\r\nStandard operators follow C's precedence order, so:\r\n\r\n    1 + 2 * 3 + 4\r\n\r\nIs parsed as:\r\n\r\n    1 +(2 *(3)) +(4)\r\n\r\nUser defined operators (that don't have a standard operator name) are performed left to right.\r\n\r\n###  Assignment\r\n\r\nIo has three assignment operators:\r\n\r\n    operator     action\r\n    ::=       Creates slot, creates setter, assigns value\r\n    :=        Creates slot, assigns value\r\n    =         Assigns value to slot if it exists, otherwise raises exception\r\n\r\nThese operators are compiled to normal messages whose methods can be overridden. For example:\r\n\r\n    source     compiles to\r\n    a ::= 1    newSlot(\"a\", 1)\r\n    a := 1     setSlot(\"a\", 1)\r\n    a = 1      updateSlot(\"a\", 1)\r\n\r\nOn *Locals* objects, **updateSlot** is overridden so it will update the *slot* in the object in which the method was activated if the *slot* is not found the locals. This is done so update assignments in methods don't require self to be an explicit target.\r\n\r\n###  Numbers\r\n\r\nThe following are examples of valid number formats:\r\n\r\n    123\r\n    123.456\r\n    0.456\r\n    ..456\r\n    123e-4\r\n    123e4\r\n    123.456e-7\r\n    123.456e2\r\n\r\nHex numbers are also supported (in any casing):\r\n\r\n    0x0\r\n    0x0F\r\n    0XeE\r\n\r\n#### Strings\r\n\r\nStrings can be defined surrounded by a single set of double quotes with escaped quotes (and other escape characters) within.\r\n\r\n    s := \"this is a \\\"test\\\".\\nThis is only a test.\"\r\n\r\nOr for strings with non-escaped characters and/or spanning many lines, triple quotes can be used.\r\n\r\n    s := \"\"\"this is a \"test\".\r\n    This is only a test.\"\"\"\r\n\r\n#### Comments\r\n\r\nComments of the //, /**/ and # style are supported. Examples:\r\n\r\n    a := b // add a comment to a line\r\n    \r\n    /* comment out a group\r\n    a := 1\r\n    b := 2\r\n    */\r\n\r\nThe \"#\" style is useful for unix scripts:\r\n\r\n    #!/usr/local/bin/io\r\n\r\nThat's it! You now know everything there is to know about Io's syntax. Control flow, objects, methods, exceptions are expressed with the syntax and semantics described above.\r\n\r\n## Objects\r\n\r\n###  Overview\r\n\r\nIo's guiding design principle is simplicity and power through conceptual unification.\r\n\r\n    concept                      unifies\r\n    scopable blocks        functions, methods, closures\r\n    prototypes             objects, classes, namespaces, locals\r\n    messages               operators, calls, assigns, var access\r\n\r\n###  Prototypes\r\n\r\nIn Io, everything is an object (including the locals storage of a block and the namespace itself) and all actions are messages (including assignment). Objects are composed of a list of key/value pairs called *slots*, and an internal list of objects from which it inherits called protos. A *slot*'s key is a symbol (a unique immutable sequence) and its value can be any type of object.\r\n\r\n#### clone and init\r\n\r\nNew objects are made by cloning existing ones. A clone is an empty object that has the parent in its list of protos. A new instance's init *slot* will be activated which gives the object a chance to initialize itself. Like NewtonScript[3], *slots* in Io are create-on-write.\r\n\r\n    me := Person clone\r\n\r\nTo add an instance variable or method, simply set it:\r\n\r\n    myDog name := \"rover\"\r\n    myDog sit := method(\"I'm sitting\\n\" print)\r\n\r\nWhen an object is cloned, its \"init\" *slot* will be called if it has one.\r\n\r\n###  Inheritance\r\n\r\nWhen an object receives a message it looks for a matching *slot*, if not found, the lookup continues depth first recursively in its protos. Lookup loops are detected (at runtime) and avoided. If the matching *slot* contains an activatable object, such as a Block or CFunction, it is activated, if it contains any other type of value it returns the value. Io has no globals and the root object in the Io namespace is called the *Lobby*.\r\n\r\nSince there are no classes, there's no difference between a subclass and an instance. Here's an example of creating the equivalent of a subclass:\r\n\r\n    Io> Dog := Object clone\r\n    ==> Object_0x4a7c0\r\n\r\nThe above code sets the *Lobby* *slot* B<\"Dog\"> to a clone of the Object object; the protos list of this new object contains only a reference to Object, essentially indicating that a subclass of Object has been created. Instance variables and methods are inherited from the objects referenced in the protos list. If a *slot* is set, it creates a new *slot* in our object instead of changing the protos:\r\n\r\n    Io> Dog color := \"red\"\r\n    Io> Dog\r\n    ==> Object_0x4a7c0:\r\n    color := \"red\"\r\n\r\n###  Multiple Inheritance\r\n\r\nYou can add any number of protos to an object's protos list. When responding to a message, the lookup mechanism does a depth first search of the proto chain.\r\n\r\n###  Methods\r\n\r\nA method is an anonymous function which, when called, creates an object to store its locals and sets the local's proto pointer and its self *slot* to the target of the message. The Object method C<method()> can be used to create methods. Example:\r\n\r\n    method((2 + 2) print)\r\n\r\nAn example of using a method in an object:\r\n\r\n    Dog := Object clone\r\n    Dog bark := method(\"woof!\" print)\r\n\r\nThe above code creates a new \"*subclass*\" of object named *Dog* and adds a *bark* *slot* containing a block that prints \"woof!\". Example of calling this method:\r\n\r\n    Dog bark\r\n\r\nThe default return value of a block is the result of the last expression.\r\n\r\n###  Arguments\r\n\r\nMethods can also be defined to take arguments. Example:\r\n\r\n    add := method(a, b, a + b)\r\n\r\nThe general form is:\r\n\r\n    method(<arg name 0>, <arg name 1>, ..., <do message>)\r\n\r\n###  Blocks\r\n\r\nA block is the same as a method except it is lexically scoped. That is, variable lookups continue in the context of where the block was created instead of the target of the message which activated the block. A block can be created using the Object method block(). Example of creating a block:\r\n\r\n    b := block(a, a + b)\r\n\r\n#### Blocks vs. Methods\r\n\r\nThis is sometimes a source of confusion so it's worth explaining in detail. Both methods and blocks create an object to hold their locals when they are called. The difference is what the \"proto\" and \"self\" slots of that locals object are set to. In a method, those slots are set to the target of the message. In a block, they're set to the locals object where the block was created. So a failed variable lookup in a block's locals continue in the locals where it was created. And a failed variable lookup in a method's locals continue in the object to which the message that activated it was sent.\r\n\r\n#### call and self slots\r\n\r\nWhen a locals object is created, its self slot is set (to the target of the message, in the case of a method, or to the creation context, in the case of a block) and its call slot is set to a Call object that can be used to access information about the block activation:\r\n\r\n    slot                       returns\r\n    call sender         locals object of caller\r\n    call message        message used to call this method/block\r\n    call activated      the activated method/block\r\n    call slotContext    context in which slot was found\r\n    call target         current object\r\n\r\n#### Variable Arguments\r\n\r\nThe \"call message\" slot in locals can be used to access the unevaluated argument messages. Example of implementing if() within Io:\r\n\r\n    myif := method(\r\n    (call sender doMessage(call message argAt(0))) ifTrue(\r\n     call sender doMessage(call message argAt(1))) ifFalse(\r\n     call sender doMessage(call message argAt(2)))\r\n    )\r\n    \r\n    myif(foo == bar, write(\"true\\n\"), write(\"false\\n\"))\r\n\r\nThe doMessage() method evaluates the argument in the context of the receiver. A shorter way to express this is to use the evalArgAt() method on the call object:\r\n\r\n    myif := method(\r\n    call evalArgAt(0) ifTrue(\r\n    call evalArgAt(1)) ifFalse(\r\n    call evalArgAt(2))\r\n    )\r\n    \r\n    myif(foo == bar, write(\"true\\n\"), write(\"false\\n\"))\r\n\r\n###  Forward\r\n\r\nIf an object doesn't respond to a message, it will invoke its \"forward\" method if it has one. Here's an example of how to print the information related lookup that failed:\r\n\r\n    MyObject forward := method(\r\n    write(\"sender = \", call sender, \"\\n\")\r\n    write(\"message name = \", call message name, \"\\n\")\r\n    args := call message argsEvaluatedIn(call sender)\r\n    args foreach(i, v, write(\"arg\", i, \" = \", v, \"\\n\") )\r\n    )\r\n\r\n###  Resend\r\n\r\nSends the current message to the receiver's protos with self as the context. Example:\r\n\r\n    A   := Object clone\r\n    A m := method(write(\"in A\\n\"))\r\n    B   := A clone\r\n    B m := method(write(\"in B\\n\"); resend)\r\n    B m\r\n\r\nwill print:\r\n\r\n    in B\r\n    in A\r\n\r\nFor sending other messages to the receiver's proto, super is used.\r\n\r\n###  Super\r\n\r\nSometimes it's necessary to send a message directly to a proto. Example:\r\n\r\n    Dog       := Object clone\r\n    Dog bark  := method(writeln(\"woof!\"))\r\n    \r\n    fido      := Dog clone\r\n    fido bark := method(\r\n        writeln(\"ruf!\")\r\n        super(bark)\r\n    )\r\n\r\nBoth resend and super are implemented in Io.\r\n\r\n###  Introspection\r\n\r\nUsing the following methods you can introspect the entire Io namespace. There are also methods for modifying any and all of these attributes at runtime.\r\n\r\n#### slotNames\r\n\r\nThe **slotNames** method returns a list of the names of an *object*'s *slots*:\r\n\r\n    Io> Dog slotNames\r\n    ==> list(\"bark\")\r\n\r\n#### protos\r\n\r\nThe protos method returns a list of the objects which an object inherits from:\r\n\r\n    Io> Dog protos\r\n    ==> list(\"Object\")\r\n\r\n#### getSlot\r\n\r\nThe \"**getSlot**\" method can be used to get the value of a block in a *slot* without activating it:\r\n\r\n    myMethod := Dog getSlot(\"bark\")\r\n\r\nAbove, we've set the locals object's \"myMethod\" slot to the bark method. It's important to remember that if you then want use the myMethod without activating it, you'll need to use the getSlot method:\r\n\r\notherObject newMethod := getSlot(\"myMethod\")\r\n\r\nHere, the target of the getSlot method is the locals object.\r\n\r\n###  code\r\n\r\nThe arguments and expressions of methods are open to introspection. A useful convenience method is \"code\", which returns a string representation of the source code of the method in a normalized form.\r\n\r\n    Io> method(a, a * 2) code\r\n    ==> \"method(a, a *(2))\"\r\n\r\n## Control Flow\r\n\r\n###  true, false and nil\r\n\r\nThere are singletons for true, false and nil. nil is typically used to indicate an unset or missing value.\r\n\r\n###  Comparison\r\n\r\nThe comparison methods:\r\n\r\n    ==, !=, >=, <=, >, <\r\n\r\nreturn either the true or false. The compare() method is used to implement the comparison methods and returns -1, 0 or 1 which mean less-than, equal-to or greater-than, respectively.\r\n\r\n###  if, then, else\r\n\r\nThe if() method can be used in the form:\r\n\r\n    if(<condition>, <do message>, <else do message>)\r\n\r\nExample:\r\n\r\n    if(a == 10, \"a is 10\" print)\r\n\r\nThe else argument is optional. The condition is considered false if the condition expression evaluates to false or nil, and true otherwise.\r\n\r\nThe result of the evaluated message is returned, so:\r\n\r\n    if(y < 10, x := y, x := 0)\r\n\r\nis the same as:\r\n\r\n    x := if(y < 10, y, 0)\r\n\r\nConditions can also be used in this form:\r\n\r\n    if(y < 10) then(x := y) else(x := 2)\r\n\r\nelseif() is supported:\r\n\r\n    if(y < 10) then(x := y) elseif(y == 11) then(x := 0) else(x := 2)\r\n\r\n#### ifTrue, ifFalse\r\n\r\nAlso supported are *Smalltalk* style **ifTrue**, **ifFalse**, **ifNil** and **ifNonNil** methods:\r\n\r\n    (y < 10) ifTrue(x := y) ifFalse(x := 2)\r\n\r\nNotice that the condition expression must have parenthesis surrounding it.\r\n\r\n###  loop\r\nThe loop method can be used for \"infinite\" loops:\r\n\r\n    loop(\"foo\" println)\r\n\r\n###  repeat\r\n\r\nThe Number **repeat** method can be used to repeat a loop a given number of times.\r\n\r\n    3 repeat(\"foo\" print)\r\n    ==> foofoofoo\r\n\r\n###  while\r\n\r\nArguments:\r\n\r\n    while(<condition>, <do message>)\r\n\r\nExample:\r\n\r\n    a := 1\r\n    while(a < 10,\r\n          a print\r\n          a = a + 1\r\n         )\r\n\r\n#### for\r\n\r\nArguments:\r\n\r\n    for(<counter>, <start>, <end>, <optional step>, <do message>)\r\n\r\nThe start and end messages are only evaluated once, when the loop starts. Example:\r\n\r\n    for(a, 0, 10,\r\n           a println\r\n       )\r\n\r\nExample with a step:\r\n\r\n    for(x, 0, 10, 3, x println)\r\n\r\nWhich would print:\r\n\r\n    0\r\n    3\r\n    6\r\n    9\r\n\r\nTo reverse the order of the loop, add a negative step:\r\n\r\n    for(a, 10, 0, -1, a println)\r\n\r\nNote: the first value will be the first value of the loop variable and the last will be the last value on the final pass through the loop. So a loop of 1 to 10 will loop 10 times and a loop of 0 to 10 will loop 11 times.\r\n\r\n#### break, continue\r\n\r\n**loop**, **repeat**, **while** and for support the **break** and **continue** methods. Example:\r\n\r\n    for(i, 1, 10,\r\n        if(i == 3, continue)\r\n        if(i == 7, break)\r\n        i print\r\n    )\r\n\r\nOutput:\r\n\r\n    12456\r\n\r\n###  return\r\n\r\nAny part of a block can return immediately using the **return** method. Example:\r\n\r\n    Io> test := method(123 print; return \"abc\"; 456 print)\r\n    Io> test\r\n    123\r\n    ==> abc\r\n\r\nInternally, **break**, **continue** and **return** all work by setting a IoState internal variable called L<\"stopStatus\"> which is monitored by the loop and message evaluation code.\r\n\r\n###  Importing\r\n\r\nThe Importer proto implements Io's built-in auto importer feature. If you put each of your proto's in their own file, and give the file the same name with and \".io\" extension, the Importer will automatically import that file when the proto is first referenced. The Importer's default search path is the current working directory, but can add search paths using its addSearchPath() method.\r\n\r\n\r\n## Concurrency\r\n\r\n###  Coroutines\r\n\r\nIo uses coroutines (user level cooperative threads), instead of preemptive OS level threads to implement concurrency. This avoids the substantial costs (memory, system calls, locking, caching issues, etc) associated with native threads and allows Io to support a very high level of concurrency with thousands of active threads.\r\n\r\n###  Scheduler\r\n\r\nThe Scheduler object is responsible for resuming coroutines that are yielding. The current scheduling system uses a simple first-in-first-out policy with no priorities.\r\n\r\n###  Actors\r\n\r\nAn actor is an object with its own thread (in our case, its own coroutine) which it uses to process its queue of asynchronous messages. Any object in Io can be sent an asynchronous message by placing using the asyncSend() or futureSend() messages.\r\n\r\nExamples:\r\n\r\n    result       := self foo // synchronous\r\n    // async, immediately returns a Future\r\n    futureResult := self futureSend(foo)\r\n    self asyncSend(foo) // async, immediately returns nil\r\n\r\nWhen an object receives an asynchronous message it puts the message in its queue and, if it doesn't already have one, starts a coroutine to process the messages in its queue. Queued messages are processed sequentially in a first-in-first-out order. Control can be yielded to other coroutines by calling \"yield\". Example:\r\n\r\n    obj1      := Object clone\r\n    obj1 test := method(for(n, 1, 3, n print; yield))\r\n    obj2      := obj1 clone\r\n    obj1 asyncSend(test); obj2 asyncSend(test)\r\n    while(Scheduler yieldingCoros size > 1, yield)\r\n\r\nThis would print \"112233\". Here's a more real world example:\r\n\r\n    HttpServer handleRequest := method(aSocket,\r\n    HttpRequestHandler clone asyncSend(handleRequest(aSocket)))\r\n\r\n###  Futures\r\n\r\nIo's futures are transparent. That is, when the result is ready, they become the result. If a message is sent to a future (besides the two methods it implements), it waits until it turns into the result before processing the message. Transparent futures are powerful because they allow programs to minimize blocking while also freeing the programmer from managing the fine details of synchronization.\r\n\r\n#### Auto Deadlock Detection\r\n\r\nAn advantage of using futures is that when a future requires a wait, it will check to see if pausing to wait for the result would cause a deadlock and if so, avoid the deadlock and raise an exception. It performs this check by traversing the list of connected futures.\r\n\r\n#### Futures and the Command Line Interface\r\n\r\nThe command line will attempt to print the result of expressions evaluated in it, so if the result is a Future, it will attempt to print it and this will wait on the result of Future. Example:\r\n\r\n    Io> q := method(wait(1))\r\n    Io> futureSend(q)\r\n    [1-second delay]\r\n    ==> nil\r\n\r\nTo avoid this, just make sure the Future isn't the result. Example:\r\n\r\n    Io> futureSend(q); nil\r\n    [no delay]\r\n    ==> nil\r\n\r\n###  Yield\r\n\r\nAn object will automatically yield between processing each of its asynchronous messages. The yield method only needs to be called if a yield is required during an asynchronous message execution.\r\n\r\n###  Pause and Resume\r\n\r\nIt's also possible to pause and resume an object. See the concurrency methods of the Object primitive for details and related methods.\r\n\r\n## Exceptions\r\n\r\n###  Raise\r\n\r\nAn exception can be raised by calling raise() on an exception proto.\r\n\r\n    Exception raise(\"generic foo exception\")\r\n\r\n###  Try and Catch\r\n\r\nTo catch an exception, the try() method of the Object proto is used. try() will catch any exceptions that occur within it and return the caught exception or nil if no exception is caught.\r\n\r\n    e := try(<doMessage>)\r\n\r\nTo catch a particular exception, the Exception catch() method can be used. Example:\r\n\r\n    e := try(\r\n        // ...\r\n    )\r\n    \r\n    e catch(Exception,\r\n    writeln(e coroutine backtraceString)\r\n    )\r\n\r\nThe first argument to catch indicates which types of exceptions will be caught. catch() returns the exception if it doesn't match and nil if it does.\r\n\r\n###  Pass\r\n\r\nTo re-raise an exception caught by try(), use the pass method. This is useful to pass the exception up to the next outer exception handler, usually after all catches failed to match the type of the current exception:\r\n\r\n    e := try(\r\n        // ...\r\n    )\r\n    \r\n    e catch(Error,\r\n            // ...\r\n            ) catch(Exception,\r\n        // ...\r\n    ) pass\r\n\r\n###  Custom Exceptions\r\n\r\nCustom exception types can be implemented by simply cloning an existing Exception type:\r\n\r\n    MyErrorType := Error clone\r\n\r\n## Primitives\r\n\r\nPrimitives are objects built into Io whose methods are typically implemented in C and store some hidden data in their instances. For example, the Number primitive has a double precision floating point number as its hidden data and its methods that do arithmetic operations are C functions. All Io primitives inherit from the Object prototype and are mutable. That is, their methods can be changed. The reference docs contain more info on primitives.\r\n\r\nThis document is not meant as a reference manual, but an overview of the base primitives and bindings is provided here to give the user a jump start and a feel for what is available and where to look in the reference documentation for further details.\r\n\r\n### Object\r\n\r\n#### The ? Operator\r\n\r\nSometimes it's desirable to conditionally call a method only if it exists (to avoid raising an exception). Example:\r\n\r\n    if(obj getSlot(\"foo\"), obj foo)\r\n\r\nPutting a \"?\" before a message has the same effect:\r\n\r\n#### obj ?foo\r\n\r\n### List\r\n\r\nA List is an array of references and supports all the standard array manipulation and enumeration methods. Examples:\r\n\r\nCreate an empty list:\r\n\r\n    a := List clone\r\n\r\nCreate a list of arbitrary objects using the list() method:\r\n\r\n    a := list(33, \"a\")\r\n\r\nAppend an item:\r\n\r\n    a append(\"b\")\r\n    ==> list(33, \"a\", \"b\")\r\n\r\nGet the list size:\r\n\r\n    a size\r\n    ==> 3\r\n\r\nGet the item at a given index (List indexes begin at zero):\r\n\r\n    a at(1)\r\n    ==> \"a\"\r\n\r\nNote: List indexes begin at zero and nil is returned if the accessed index doesn't exist.\r\n\r\nSet the item at a given index:\r\n\r\n    a atPut(2, \"foo\")\r\n    ==> list(33, \"a\", \"foo\", \"b\")\r\n\r\n    a atPut(6, \"Fred\")\r\n    ==> Exception: index out of bounds\r\n\r\nRemove an item at a given index:\r\n\r\n    a remove(\"foo\")\r\n    ==> list(33, \"a\", \"b\")\r\n\r\nInserting an item at a given index:\r\n\r\n    a atInsert(2, \"foo\")\r\n    ==> list(33, \"a\", \"foo\", \"56\")\r\n\r\n#### foreach\r\n\r\nThe foreach, map and select methods can be used in three forms:\r\n\r\n    Io> a := list(65, 21, 122)\r\n\r\nIn the first form, the first argument is used as an index variable, the second as a value variable and the 3rd as the expression to evaluate for each value.\r\n\r\n    Io> a foreach(i, v, write(i, \":\", v, \", \"))\r\n    ==> 0:65, 1:21, 2:122,\r\n\r\nThe second form removes the index argument:\r\n\r\n    Io> a foreach(v, v println)\r\n    ==> 65\r\n        21\r\n        122\r\n\r\nThe third form removes the value argument and simply sends the expression as a message to each value:\r\n\r\n    Io> a foreach(println)\r\n    ==> 65\r\n        21\r\n        122\r\n\r\n###  map and select\r\n\r\nIo's map and select (known as filter in some other languages) methods allow arbitrary expressions as the map/select predicates.\r\n\r\n    Io> numbers := list(1, 2, 3, 4, 5, 6)\r\n\r\n    Io> numbers select(isOdd)\r\n    ==> list(1, 3, 5)\r\n\r\n    Io> numbers select(x, x isOdd)\r\n    ==> list(1, 3, 5)\r\n\r\n    Io> numbers select(i, x, x isOdd)\r\n    ==> list(1, 3, 5)\r\n\r\n    Io> numbers map(x, x*2)\r\n    ==> list(2, 4, 6, 8, 10, 12)\r\n\r\n    Io> numbers map(i, x, x+i)\r\n    ==> list(1, 3, 5, 7, 9, 11)\r\n\r\n    Io> numbers map(*3)\r\n    ==> list(3, 6, 9, 12, 15, 18)\r\n\r\nThe map and select methods return new lists. To do the same operations in-place, you can use selectInPlace() and mapInPlace() methods.\r\n\r\n###  Sequence\r\n\r\nIn Io, an immutable Sequence is called a Symbol and a mutable Sequence is the equivalent of a Buffer or String. Literal strings(ones that appear in source code surrounded by quotes) are Symbols. Mutable operations cannot be performed on Symbols, but one can make mutable copy of a Symbol calling its asMutable method and then perform the mutation operations on the copy. Common string operations Getting the length of a string:\r\n\r\n    \"abc\" size\r\n    ==> 3\r\n\r\nChecking if a string contains a substring:\r\n\r\n    \"apples\" containsSeq(\"ppl\")\r\n    ==> true\r\n\r\nGetting the character (byte) at position N:\r\n\r\n    \"Kavi\" at(1)\r\n    ==> 97\r\n\r\nSlicing:\r\n\r\n    \"Kirikuro\" slice(0, 2)\r\n    ==> \"Ki\"\r\n\r\n    \"Kirikuro\" slice(-2)  # NOT: slice(-2, 0)!\r\n    ==> \"ro\"\r\n\r\n    Io> \"Kirikuro\" slice(0, -2)\r\n    # \"Kiriku\"\r\n\r\nStripping whitespace:\r\n\r\n    \"  abc  \" asMutable strip\r\n    ==> \"abc\"\r\n    \r\n    \"  abc  \" asMutable lstrip\r\n    ==> \"abc  \"\r\n    \r\n    \"  abc  \" asMutable rstrip\r\n    ==> \"  abc\"\r\n\r\nConverting to upper/lowercase:\r\n\r\n    \"Kavi\" asUppercase\r\n    ==> \"KAVI\"\r\n    \"Kavi\" asLowercase\r\n    ==> \"kavi\"\r\n\r\nSplitting a string:\r\n\r\n    \"the quick brown fox\" split\r\n    ==> list(\"the\", \"quick\", \"brown\", \"fox\")\r\n\r\nSplitting by others character is possible as well.\r\n\r\n    \"a few good men\" split(\"e\")\r\n    ==> list(\"a f\", \"w good m\", \"n\")\r\n\r\nConverting to number:\r\n\r\n    \"13\" asNumber\r\n    ==> 13\r\n    \r\n    \"a13\" asNumber\r\n    ==> nil\r\n    \r\n    String interpolation:\r\n    \r\n    name := \"Fred\"\r\n    ==> Fred\r\n    \"My name is #{name}\" interpolate\r\n    ==> My name is Fred\r\n\r\nInterpolate will eval anything with #{} as Io code in the local context. The code may include loops or anything else but needs to return an object that responds to asString.\r\n\r\n### Ranges\r\n\r\nA range is a container containing a start and an end point, and instructions on how to get from the start, to the end. Using Ranges is often convenient when creating large lists of sequential data as they can be easily converted to lists, or as a replacement for the for() method.\r\n\r\n#### The Range protocol\r\n\r\nEach object that can be used in Ranges needs to implement a \"nextInSequence\" method which takes a single optional argument (the number of items to skip in the sequence of objects), and return the next item after that skip value. The default skip value is 1. The skip value of 0 is undefined. An example:\r\n\r\n    Number nextInSequence := method(skipVal,\r\n        if(skipVal isNil, skipVal = 1)\r\n            self + skipVal\r\n    )\r\n\r\nWith this method on Number (it's already there in the standard libraries), you can then use Numbers in Ranges, as demonstrated below:\r\n\r\n    1 to(5) foreach(v, v println)\r\n\r\nThe above will print 1 through 5, each on its own line.\r\n\r\n###  File\r\n\r\nThe methods openForAppending, openForReading, or openForUpdating are used for opening files. To erase an existing file before opening a new open, the remove method can be used. Example:\r\n\r\n    f := File with(\"foo.txt)\r\n    f remove\r\n    f openForUpdating\r\n    f write(\"hello world!\")\r\n    f close\r\n\r\n#### Directory\r\n\r\nCreating a directory object:\r\n\r\n    dir := Directory with(\"/Users/steve/\")\r\n\r\nGet a list of file objects for all the files in a directory:\r\n\r\n    files := dir files\r\n    ==> list(File_0x820c40, File_0x820c40, ...)\r\n\r\nGet a list of both the file and directory objects in a directory:\r\n\r\n    items := Directory items\r\n    ==> list(Directory_0x8446b0, File_0x820c40, ...)\r\n    \r\n    items at(4) name\r\n    ==> DarkSide-0.0.1 # a directory name\r\n\r\nSetting a Directory object to a certain directory and using it:\r\n\r\n    root := Directory clone setPath(\"c:/\")\r\n    ==> Directory_0x8637b8\r\n    \r\n    root fileNames\r\n    ==> list(\"AUTOEXEC.BAT\", \"boot.ini\", \"CONFIG.SYS\", ...)\r\n    \r\n    Testing for existence:\r\n    \r\n    Directory clone setPath(\"q:/\") exists\r\n    ==> false\r\n\r\nGetthing the current working directory:\r\n\r\n    Directory currentWorkingDirectory\r\n    ==> \"/cygdrive/c/lang/IoFull-Cygwin-2006-04-20\"\r\n\r\n###  Date\r\n\r\nCreating a new date instance:\r\n\r\n    d := Date clone\r\n    \r\n    Setting it to the current date/time:\r\n    \r\n    d now\r\n\r\nGetting the date/time as a number, in seconds:\r\n\r\n    Date now asNumber\r\n    ==> 1147198509.417114\r\n    \r\n    Date now asNumber\r\n    ==> 1147198512.33313\r\n\r\nGetting individual parts of a Date object:\r\n\r\n    d := Date now\r\n    ==> 2006-05-09 21:53:03 EST\r\n    \r\n    d\r\n    ==> 2006-05-09 21:53:03 EST\r\n    \r\n    d year\r\n    ==> 2006\r\n    \r\n    d month\r\n    ==> 5\r\n    \r\n    d day\r\n    ==> 9\r\n    \r\n    d hour\r\n    ==> 21\r\n    \r\n    d minute\r\n    ==> 53\r\n    \r\n    d second\r\n    ==> 3.747125\r\n\r\nFind how long it takes to execute some code:\r\n\r\n    Date cpuSecondsToRun(100000 repeat(1+1))\r\n    ==> 0.02\r\n\r\n###  Networking\r\n\r\nAll of Io's networking is done with asynchronous sockets underneath, but operations like reading and writing to a socket appear to be synchronous since the calling coroutine is unscheduled until the socket has completed the operation, or a timeout occurs. Note that you'll need to first reference the associated addon in order to cause it to load before using its objects. In these examples, you'll have to reference \"Socket\" to get the Socket addon to load first.\r\n\r\nCreating a URL object:\r\n\r\n    url := URL with(\"http://example.com/\")\r\n\r\nFetching an URL:\r\n\r\n    data := url fetch\r\n\r\nStreaming a URL to a file:\r\n\r\n  url streamTo(File with(\"out.txt\"))\r\n\r\n\r\nA simple whois client:\r\n\r\n    whois := method(host,\r\n            socket := Socket clone \\\r\n            setHostName(\"rs.internic.net\") setPort(43)\r\n            socket connect streamWrite(host, \"\\n\")\r\n    while(socket streamReadNextChunk, nil)\r\n        return socket readBuffer\r\n    )\r\n\r\nA minimal web server:\r\n\r\n    WebRequest := Object clone do(\r\n            handleSocket := method(aSocket,\r\n            aSocket streamReadNextChunk\r\n            request := aSocket readBuffer \\\r\n            betweenSeq(\"GET \", \" HTTP\")\r\n            f := File with(request)\r\n            if(f exists,\r\n               f streamTo(aSocket)\r\n               ,\r\n               aSocket streamWrite(\"not found\")\r\n               )\r\n               aSocket close\r\n            )\r\n        )\r\n    \r\n        WebServer := Server clone do(\r\n                setPort(8000)\r\n                handleSocket := method(aSocket,\r\n                WebRequest clone asyncSend(handleSocket(aSocket))\r\n        )\r\n    )\r\n    WebServer start\r\n\r\n###  XML\r\n\r\nUsing the XML parser to find the links in a web page:\r\n\r\n    SGML // reference this to load the SGML addon\r\n    xml   := URL with(\"http://www.yahoo.com/\") fetch asXML\r\n    links := xml elementsWithName(\"a\") map(attributes at(\"href\"))\r\n\r\n###  Vector\r\n\r\nIo's Vectors are built on its Sequence primitive and are defined as:\r\n\r\n    Vector := Sequence clone setItemType(\"float32\")\r\n\r\nThe Sequence primitive supports SIMD acceleration on a number of float32 operations. Currently these include add, subtract, multiple and divide but in the future can be extended to support most math, logic and string manipulation related operations. Here's a small example:\r\n\r\n    iters := 1000\r\n    size  := 1024\r\n    ops   := iters * size\r\n    \r\n    v1    := Vector clone setSize(size) rangeFill\r\n    v2    := Vector clone setSize(size) rangeFill\r\n    \r\n    dt    := Date secondsToRun(\r\n    iters repeat(v1 *= v2)\r\n    )\r\n    \r\n    writeln((ops/(dt*1000000000)) asString(1, 3), \" GFLOPS\")\r\n\r\nWhich when run on 2Ghz Mac Laptop, outputs:\r\n\r\n    1.255 GFLOPS\r\n\r\nA similar bit of C code (without SIMD acceleration) outputs:\r\n\r\n    0.479 GFLOPS\r\n\r\nSo for this example, Io is about three times faster than plain C.\r\n\r\n\r\n## Unicode\r\n\r\n###  Sequences\r\n\r\nIn Io, symbols, strings, and vectors are unified into a single Sequence prototype which is an array of any available hardware data type such as:\r\n\r\n    uint8, uint16, uint32, uint64\r\n    int8, int16, int32, int64\r\n    float32, float64\r\n\r\n#### Encodings\r\n\r\nAlso, a Sequence has a encoding attribute, which can be:\r\n\r\n#### number, ascii, ucs2, ucs4, utf8\r\n\r\nUCS-2 and UCS-4 are the fixed character width versions of UTF-16 and UTF-32, respectively. A String is just a Sequence with a text encoding, a Symbol is an immutable String and a Vector is a Sequence with a number encoding.\r\n\r\nUTF encodings are assumed to be big endian.\r\n\r\nExcept for input and output, all strings should be kept in a fixed character width encoding. This design allows for a simpler implementation, code sharing between vector and string ops, fast index-based access, and SIMD acceleration of Sequence operations. All Sequence methods will do automatic type conversions as needed.\r\n\r\n###  Source Code\r\n\r\nIo source files are assumed to be in UTF8 (of which ASCII is a subset). When a source file is read, its symbols and strings are stored in Sequences in their minimal fixed character width encoding. Examples:\r\n\r\n    Io> \"hello\" encoding\r\n    ==> ascii\r\n    \r\n    Io> \"π\" encoding\r\n    ==> ucs2\r\n    \r\n    Io> \"∞\" encoding\r\n    ==> ucs2\r\n    \r\n    We can also inspect the internal representation:\r\n    \r\n    Io> \"π\" itemType\r\n    ==> uint16\r\n    \r\n    Io> \"π\" itemSize\r\n    ==> 2\r\n\r\n###  Conversion\r\n\r\nThe Sequence object has a number of conversion methods:\r\n    asUTF8\r\n    asUCS2\r\n    asUCS4\r\n\r\n## Embedding\r\n\r\n###  Conventions\r\n\r\nIo's C code is written using object oriented style conventions where structures are treated as objects and functions as methods. Familiarity with these may help make the embedding APIs easier to understand.\r\n\r\n#### Structures\r\n\r\nMember names are words that begin with a lower case character with successive words each having their first character upper cased. Acronyms are capitalized. Structure names are words with their first character capitalized. Example:\r\n\r\n    typdef struct\r\n    {\r\n        char *firstName;\r\n        char *lastName;\r\n        char *address;\r\n    } Person;\r\n\r\n#### Functions\r\n\r\nFunction names begin with the name of structure they operate on followed by an underscore and the method name. Each structure has a new and free function.\r\n\r\nExample:\r\n\r\n    List *List_new(void);\r\n    void List_free(List *self);\r\n\r\nAll methods (except new) have the structure (the \"object\") as the first argument the variable is named \"self\". Method names are in keyword format. That is, for each argument, the method name has a description followed by an underscore. The casing of the descriptions follow that of structure member names.\r\n\r\nExamples:\r\n\r\n    int List_count(List *self); // no argument\r\n    void List_add_(List *self, void *item); // one argument\r\n    void Dictionary_key_value_(Dictionary *self,\r\n            char *key, char *value);\r\n\r\n#### File Names\r\n\r\nEach structure has its own separate .h and .c files. The names of the files are the same as the name of the structure. These files contain all the functions(methods) that operate on the given structure.\r\n\r\n###  IoState\r\n\r\nAn IoState can be thought of as an instance of an Io \"virtual machine\", although \"virtual machine\" is a less appropriate term because it implies a particular type of implementation.\r\n\r\n#### Multiple states\r\n\r\nIo is multi-state, meaning that it is designed to support multiple state instances within the same process. These instances are isolated and share no memory so they can be safely accessed simultaneously by different os threads, though a given state should only be accessed by one os thread at a time.\r\n\r\n#### Creating a state\r\n\r\nHere's a simple example of creating a state, evaluating a string in it, and freeing the state:\r\n\r\n    #include \"IoState.h\"\r\n    \r\n    int main(int argc, const char *argv[])\r\n    {\r\n        IoState *self = IoState_new();\r\n        IoState_init(self);\r\n        IoState_doCString_(self, \"writeln(\\\"hello world!\\\"\");\r\n        IoState_free(self);\r\n        return 0;\r\n    }\r\n\r\n###  Values\r\n\r\nWe can also get return values and look at their types and print them:\r\n\r\n    IoObject *v = IoState_doCString_(self, someString);\r\n    char *name = IoObject_name(v);\r\n    printf(\"return type is a ‘%s', name);\r\n    IoObject_print(v);\r\n\r\n#### Checking value types\r\n\r\nThere are some macro short cuts to help with quick type checks:\r\n\r\n    if (ISNUMBER(v))\r\n    {\r\n        printf(\"result is the number %f\", IoNumber_asFloat(v));\r\n    }\r\n    else if(ISSEQ(v))\r\n    {\r\n        printf(\"result is the string %s\", IoSeq_asCString(v));\r\n    }\r\n    else if(ISLIST(v))\r\n    {\r\n        printf(\"result is a list with %i elements\",\r\n                IoList_rawSize(v));\r\n    }\r\n\r\nNote that return values are always proper Io objects (as all values are objects in Io). You can find the C level methods (functions like IoList_rawSize()) for these objects in the header files in the folder Io/libs/iovm/source.\r\n\r\n## Bindings\r\n\r\nDocumentation on how to write bindings/addons forthcoming..\r\n\r\n## Appendix\r\n\r\n###  Grammar\r\n\r\n#### messages\r\n\r\n    expression ::= { message | sctpad }\r\n    message    ::= [wcpad] symbol [scpad] [arguments]\r\n    arguments  ::= Open [argument [ { Comma argument } ]] Close\r\n    argument   ::= [wcpad] expression [wcpad]\r\n\r\n###  symbols\r\n\r\n    symbol ::= Identifier | number | Operator | quote\r\n    Identifier ::= { letter | digit | \"_\" }\r\n    Operator ::= { \":\" | \".\" | \"'\" | \"~\" | \"!\" | \"@\" | \"$\" |\r\n    \"%\" | \"^\" | \"&\" | \"*\" | \"-\" | \"+\" | \"/\" | \"=\" | \"{\" | \"}\" |\r\n    \"[\" | \"]\" | \"|\" | \"\\\" | \"<\" | \">\" | \"?\" }\r\n\r\n###  quotes\r\n\r\n    quote     ::= MonoQuote | TriQuote\r\n    MonoQuote ::= \"\"\" [ \"\\\"\" | not(\"\"\")] \"\"\"\r\n    TriQuote  ::= \"\"\"\"\" [ not(\"\"\"\"\")] \"\"\"\"\"\r\n\r\n###  spans\r\n\r\n    Terminator ::= { [separator] \";\" | \"\\n\" | \"\\r\" [separator] }\r\n    separator  ::= { \" \" | \"\\f\" | \"\\t\" | \"\\v\" }\r\n    whitespace ::= { \" \" | \"\\f\" | \"\\r\" | \"\\t\" | \"\\v\" | \"\\n\" }\r\n    sctpad     ::= { separator | Comment | Terminator }\r\n    scpad      ::= { separator | Comment }\r\n    wcpad      ::= { whitespace | Comment }\r\n\r\n###  comments\r\n\r\n    Comment           ::= slashStarComment | slashSlashComment | poundComment\r\n    slashStarComment  ::= \"/*\" [not(\"*/\")] \"*/\"\r\n    slashSlashComment ::= \"//\" [not(\"\\n\")] \"\\n\"\r\n    poundComment      ::= \"#\" [not(\"\\n\")] \"\\n\"\r\n\r\n###  numbers\r\n\r\n    number    ::= HexNumber | Decimal\r\n    HexNumber ::= \"0\" anyCase(\"x\") { [ digit | hexLetter ] }\r\n    hexLetter ::= \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\r\n    Decimal   ::= digits | \".\" digits |\r\n    digits \".\" digits [\"e\" [-] digits]\r\n\r\n###  characters\r\n\r\n    Comma   ::= \",\"\r\n    Open    ::= \"(\" | \"[\" | \"{\"\r\n    Close   ::= \")\" | \"]\" | \"}\"\r\n    letter  ::= \"a\" ... \"z\" | \"A\" ... \"Z\"\r\n    digit   ::= \"0\" ... \"9\"\r\n    digits  ::= { digit }\r\n\r\nThe uppercase words above designate elements the lexer treats as tokens.\r\n\r\n###  Credits\r\n\r\nIo is the product of all the talented folks who taken the time and interest to make a contribution. The complete list of contributors is difficult to keep track of, but some of the recent major contributors include; Jonathan Wright, Jeremy Tregunna, Mike Austin, Chris Double, Rich Collins, Oliver Ansaldi, James Burgess, Baptist Heyman, Ken Kerahone, Christian Thater, Brian Mitchell, Zachary Bir and many more. The mailing list archives, repo inventory and release history are probably the best sources for a more complete record of individual contributions.\r\n\r\n###  References\r\n\r\n    1. Goldberg, A et al.\r\n    Smalltalk-80: The Language and Its Implementation\r\n    Addison-Wesley, 1983\r\n    \r\n    2. Ungar, D and Smith,\r\n    RB. Self: The Power of Simplicity\r\n    OOPSLA, 1987\r\n    \r\n    3. Smith, W.\r\n    Class-based NewtonScript Programming\r\n    PIE Developers magazine, Jan 1994\r\n    \r\n    4. Lieberman\r\n    H. Concurrent Object-Oriented Programming in Act 1\r\n    MIT AI Lab, 1987\r\n    \r\n    5. McCarthy, J et al.\r\n    LISP I programmer's manual\r\n    MIT Press, 1960\r\n    \r\n    6. Ierusalimschy, R, et al.\r\n    Lua: an extensible extension language\r\n    John Wiley & Sons, 1996\r\n\r\n###  License\r\n\r\nCopyright 2006-2010 Steve Dekorte. All rights reserved.\r\n\r\nRedistribution and use of this document with or without modification, are permitted provided that the copies reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n\r\nThis documentation is provided \"as is\" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the authors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this documentation, even if advised of the possibility of such damage.","google":"Io language Guide","note":"Don't delete this file! It's used internally to help with page regeneration."}